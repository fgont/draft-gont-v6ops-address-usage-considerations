<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc strict="no" ?>

<rfc 
	ipr="noDerivativesTrust200902"
	category="info"
	docName="draft-gont-v6ops-address-usage-considerations-00">
  <front>
    <title abbrev="IPv6 Address Usage">IPv6 Address Usage Considerations</title>

    <author fullname="Fernando Gont" initials="F." surname="Gont">
      <organization abbrev="SI6 Networks / UTN-FRH">SI6 Networks / UTN-FRH</organization>

      <address>
        <postal>
          <street>Evaristo Carriego 2644</street>
          <code>1706</code>
          <city>Haedo</city>
          <region>Provincia de Buenos Aires</region>
          <country>Argentina</country>
        </postal>
<!--
        <phone>+54 11 4650 8472</phone>
-->
        <email>fgont@si6networks.com</email>
        <uri>https://www.si6networks.com</uri>
      </address>
    </author>


    <author fullname="Guillermo Gont" initials="G.G." surname="Gont">
      <!-- abbrev not needed but can be used for the header
         if the full organization name is too long -->

      <organization abbrev="SI6 Networks">SI6 Networks</organization>

      <address>
        <postal>
          <!-- I've omitted my street address here -->

          <street>Evaristo Carriego 2644</street>

          <code>1706</code>

          <city>Haedo</city>

          <region>Provincia de Buenos Aires</region>

          <country>Argentina</country>
        </postal>

        <email>ggont@si6networks.com</email>

        <uri>https://www.si6networks.com</uri>
      </address>
    </author>	


   <author fullname="Christian Huitema" initials="C." surname="Huitema">
      <organization>Private Octopus Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Friday Harbor</city>
          <code>98250</code>
          <region>WA</region>
          <country>U.S.A.</country>
        </postal>
        <email>huitema@huitema.net</email>
        <uri>http://privateoctopus.com</uri>
      </address>
    </author>

    <date/>


    <area>Operations and Management</area>
    <workgroup>IPv6 Operations Working Group (v6ops)</workgroup>



    <abstract>
    <t>
IPv6 addresses may differ in a number of properties, such as scope, stability, and intended usage type. This document analyzes the impact of these properties on aspects such as security, privacy, interoperability, and network operations, with the goal of providing guidance about IPv6 address usage. Additionally, it identifies challenges and gaps that currently prevent systems and applications from leveraging the increased flexibility and availability of IPv6 addresses. 
</t>
    </abstract>
  </front>

  <middle>
  
<section title="Introduction" anchor="intro">
<t>IPv6 addresses may differ in a number of properties, such as address scope (e.g. link-local vs. global), stability (e.g. stable addresses vs. temporary addresses), and intended usage type (outgoing communications vs. incoming communications). While often overlooked, these properties have impact on areas such as security, privacy, interoperability, and network operations.
</t>

<t>IPv6 hosts typically configure addresses based on local system policy, which tends to be static and irrespective of the specific network the host attaches to. For example, most IPv6 host implementations configure one link-local address for each network interface, and one stable and one (or more) temporary addresses per each autoconfiguration prefix advertised via SLAAC for each network interface. Additionally, in scenarios where the network provides address configuration via both SLAAC and DHCPv6, host typically configure addresses using both protocols; as a result, host will typically add one DHPv6-leased address per local prefix.</t>

<t>Each application in use on a given system may have its own set of requirements or expectations for the properties of the underlying IPv6 addresses. For example, an application meaning to offer a public service might expect to employ globally-reachable <xref target="RFC8190"/> stable addresses <xref target="RFC7721"/> <xref target="RFC8064"/>, while a privacy-sensible client application might prefer short-lived temporary addresses <xref target="I-D.ietf-6man-rfc4941bis"/>, or might even expect to employ single-use ("throw-away") IPv6 addresses when connecting to public servers. However, the subtleties associated with IPv6 addresses, and the corresponding properties, are often ignored or overlooked by application programmers and network administrators. Additionally, there are a number of challenges associated with IPv6 address usage, ranging from limitations in the current Application Programming Interfaces (APIs) to implementation constraints in network devices, which may limit the ability to leverage the IPv6 address availability and properties. This typically leads to suboptimal use of the increased IPv6 address availability and flexibility and, at times, event to unintended consequences.</t>
<!--
<t>Additionally, current APIs (such as the BSD Sockets API) tend to be very limited in the amount of control they give applications to select the most appropriate IPv6 addresses for a given task, thus limiting a programmer's ability to leverage IPv6 address availability and properties.</t>
-->

<t>This document identifies a set of properties that can be associated with IPv6 addresses (such as scope, stability, and others), and analyzes the impact of these properties on areas ranging from privacy to network operations, with the goal of providing guidance about IPv6 address usage. Finally, it identifies challenges and gaps that prevent systems and applications from fully-leveraging IPv6 addressing capabilities, with the goal of triggering further work that may help overcome the aforementioned challenges and fill the identified gaps.</t>
</section>


<section title="Terminology" anchor="terminology">

<t>This document employs the definitions of "public address", "stable address", and "temporary address" from Section 2 of <xref target="RFC7721"/>.</t>

<t>This document employs the definition of "globally reachable" from Section 2.1 of <xref target="RFC8190"/>.</t>

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
   NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   RFC 2119 <xref target="RFC2119"/>.</t>
</section>


<section title="Background" anchor="background">

<t>Legacy schemes to auto-configure IPv6 addresses, such as SLAAC stable addresses embedding the underlying link-layer address in the IPv6 Interface Identifier (IID) <xref target="RFC4291"/> and temporary addresses reusing IIDs for multiple auto-configuration prefixes <xref target="RFC4941"/> have well-known security and privacy implications. For example, <xref target="Barnes2012"/> discusses how patterns in network prefixes can be leveraged for IPv6 address scanning, while <xref target="RFC7707"/>, 
<xref target="RFC7721"/> and <xref target="RFC7217"/> discuss the security and privacy 
implications of predictable IPv6 Interface Identifiers.</t>

<t>As a result of the aforementioned work, those legacy schemes have been formally superseded by other schemes, such as <xref target="RFC7217"/> and <xref target="I-D.ietf-6man-rfc4941bis"/>. As a result, we expect and assume in the rest of this document 
that implementations have been updated to implement the improved schemes, and hence do not discuss any implications arising from the legacy IID generation algorithms.</t>



</section>

<section title="IPv6 Address Properties" anchor="address-considerations">

<t>There are, at least, five properties that can be associated with every IPv6 address:

<list style="symbols">
<t>Scope</t>
<t>Reachability</t>
<!-- <t>Provider Dependency</t> -->
<t>Stability</t>
<t>Usage type</t>
</list>
</t>


<t>The address scope essentially represents the area of the network where an address can be expected to uniquely identify a system or set of systems. For example, link-local addresses are expected to be unique on the same network link. However, nodes might employ the same link-local address on different links.</t>

<t>Address reachability represents the area of the network (and the associated conditions), where an address can be expected to be used for receiving and transmitting packets. Reachability is associated with address scope, but the two are different properties: global scope is simply a necessary -- but not sufficient -- property for global reachability. For example, Unique-Local Addresses (ULAs) have global scope (and thus expected to be statistically unique), but are not forwardable beyond a specified administrative domain, and hence are not globally reachable <xref target="RFC8190"/>. Besides the semantics of specific address types, reachability may be also affected by network devices: for example, Customer Edge Routers that enforce a filtering policy of "only allowing outgoing communications" may render otherwise globally reachable addresses as unreachable from the public Internet, unless communication is initiated from the home network.</t>


<t>The stability of an address is associated with the invariance of an address over time. For example, a manually-configured address will typically remain stable while the node remains attached to the same subnet, while a temporary address will, by definition, change over time. <!--Finally, temporary addresses <ref target="RFC4941"/> <xref target="I-D.ietf-6man-rfc4941bis"/> are specifically meant to be employed for "outgoing communications", and typically employed along with stable addresses, that in such cases are meant only for incoming communications. --></t>

<t>IPv6 hosts may typically automatically-configure (whether via SLAAC or via DHCPv6) both stable <xref target="RFC8064"/> and/or temporary <xref target="RFC4941"/> addresses. When both stable and temporary addresses are configured, stable addresses are typically employed for incoming (server-like) communications, while temporary addresses are employed for outgoing (client-like) communications.
</t>

<!--
<t>
<xref target="scope-considerations"/>, 
<xref target="stability-considerations"/>, and <xref target="usage-type-considerations"/> 
discuss the security and privacy implications (and associated tradeoffs) of the scope, 
stability and usage type properties of IPv6 addresses, respectively.
</t>
-->
<!--
<t>Additionally, IPv6 address usage has a number of operational considerations; these are discussed n <xref target="operational-considerations"/>.
</t>
-->

<section title="Address Scope Considerations" anchor="scope-considerations">

<t>The IPv6 address scope <xref target="RFC4007"/> has a direct implication on address reachability: addresses that have a non-global scope are, in principle, not globally reachable.
<list style="hanging">
<t hangText="NOTE:"><vspace blankLines="0"/>The assumption becomes invalid if Network Prefix Translation (NPT) <xref target="RFC6296"/> is employed, though.</t>
</list>
</t>
<t>
The IPv6 address scope can, in some scenarios, limit the attack exposure of a node as a result 
of the implicit isolation provided by a non-global address scope. For example, a node that 
only employs link-local addresses may, in principle, only be exposed to attacks from other 
nodes in the local link. Unique Local Addresses (ULAs), while having a global scope (and hence expected to be globally unique), are not globally-reachable, and thus they provide address-based isolation as non-global addresses.
</t>

<t>The potential protection provided by a non-global-scope addresses (and the ULA specific case) should not be regarded as a 
complete security strategy, but rather as a form of "prophylactic" security 
(see <xref target="I-D.gont-opsawg-firewalls-analysis"/>).
</t>

<t>We note that the use of non-global scope addresses is usually limited to a reduced type of 
applications/protocols that e.g. are only meant to operate on a reduced scope, and hence 
their applicability may be limited.</t>

<t>In some cases, the address scope may affect address stability. For example, a home network may internally employ both ULAs and GUAs, where the GUAs are configured from a prefix leased via DHCPv6 Prefix Delegation <xref target="RFC8415"/>. If for some reason there was an outage involving the connection with the upstream ISP, the prefix lease time could eventually expire, and therefore addresses configured for such prefix would need to be invalidated. Similarly, if upon prefix lease expiration the ISP were to lease a new IPv6 prefix rather than renew the previously employed prefix, the network would need to be renumbered. On the other hand, ULA prefixes advertised by the CE Router will normally not require renewal from the ISP, since they are locally generated by the CE Router.
<list style="hanging">
<t hangText="NOTE:"><vspace blankLines="0"/>As noted above, while strictly speaking ULAs belong to the global unicast address space, they can be considered non-global addresses for all practical purposes.</t>
</list>
</t>

<t>A discussion of ULA usage considerations can be found in 
<xref target="I-D.ietf-v6ops-ula-usage-considerations"/>.</t>
</section>

<!--
<section title="Provider Dependency" anchor="dependency">
<t>Provider-dependency is typically discussed in the context of Global Unicast Addresses: the Global Unicast Address Space can be categorized as either Provider-Aggregatable (PA) address space, or Provider-Aggregatable (PA) address space.</t>
Provider-Aggregatable (PA) address space is typically an address block assigned by a Regional Internet Registry (RIR) to an Internet Service Provider (ISP), which in turn supplies parts of this address space to other organizations. Thus, the ISP can aggregate the address space of all such organizations into a single route advertisement.</t>
<t>On the other hand, Provider-Aggregatable (PA) address space is typically an address block assigned by a RIR directly to an end-user organization.</t>

<t>End-user organizations that employ PA space typically need to perform network renumbering when switching ISPs. On the other hand, end-user organizations employing PI space need not perform network renumbering, since the address space is assigned to the end-user organization itself, rather than to the ISP.
</t>

</section>
-->

<section title="Address Reachability" anchor="reachability">
<t>Address reachability represents the area of the network (and the associated conditions), where an address can be expected to be used for receiving and transmitting packets. As noted in <xref target="scope-considerations"/>, the address scope has a direct implication on address reachability: only global-scope addresses can be globally reachable.</t>

<t>However, besides the reachability semantics of each address type, network filtering policies may also affect address reachability. For example, there is widespread deployment of Customer Edge Routers that implement a (stateful) filtering policy of "only allowing outgoing communications" -- mimicking the filtering policy enforced (as a side-effect) by IPv4 NATs. In such scenarios, even otherwise globally-reachable addresses becomes unreachable, unless communication is initiated from the internal network, the CE Router is manually configured override the default filtering policy, or a technology to dynamically override the filtering policy (such as UPnP <xref target="UPnP"/>) is employed.</t>

<t>Address reachability is what ultimately determines the application architecture that may be employed by an IPv6 node.
<list style="hanging">
<t hangText="NOTE:"><vspace blankLines="0"/>Ironically, an IPv6-only host (with global-scope addresses) attached to a home network where the CE Router "only allows outgoing communications" and does not implement UPnP <xref target="UPnP"/> will normally have a harder time using peer-to-peer (P2P) applications than an IPv4-only host (with a private address) attached to a home network where the CE Router employs NAT but implements UPnP.
</t>
</list>
</t>

</section>


<section title="Address Stability Considerations" anchor="stability-considerations">
<t>The stability of an address has two associated security/privacy implications:
<list style="symbols">
<t>Ability of an attacker to correlate network activity</t>
<t>Exposure to attack</t>
</list>

</t>

<t>
For obvious reasons, an address that is employed for multiple communication instances 
allows the aforementioned network activities to be correlated. The longer an address 
is employed (i.e., the more stable it is), the longer such correlation will be possible. 
In the worst-case scenario, a stable address that is employed for multiple communication 
instances over time will allow all such activities to be correlated. On the other hand, 
if a host were to generate (and eventually "throw away") one new address for each 
communication instance (e.g., TCP connection), network activity correlation would be mitigated. 

<list style="hanging">
<t hangText="NOTE:"><vspace blankLines="0"/>The security and privacy implications of predictable addresses is summarized in <xref target="background"/>.
</t>
</list>
</t>


<t>Typically, when it comes to attack exposure, the longer an address is employed the longer 
an attacker is exposed to attacks. While such exposure is traditionally associated with 
the stability of the address, the usage type of the address 
 may also have an impact on attack exposure (see <xref target="usage-type-considerations"/>).
</t>


<t>A popular approach to mitigate network activity correlation is the use of "temporary 
addresses" <xref target="RFC4941"/>. Temporary addresses are typically auto-configured and 
employed along with stable addresses, with the temporary addresses employed for outgoing 
communications, and the stable addresses employed for incoming communications.

<list style="hanging">
<t hangText="NOTE:"><vspace blankLines="0"/>Ongoing work <xref target="I-D.ietf-6man-rfc4941bis"/> aims at updating 
<xref target="RFC4941"/> such that temporary addresses can be employed without the 
need to configure stable addresses.</t>
</list>

We note that the extent to which temporary addresses provide improved mitigation of 
network activity correlation and/or reduced attack exposure may be questionable 
and/or limited in some scenarios. For example, a temporary address that is reachable 
for, say, a few hours has a questionable "reduced exposure" (particularly when 
automated attack tools do not typically require such a long period of time to 
complete their task). Similarly, if network activity can be correlated for the 
life of such address (e.g., on the order of several hours), such period of time might 
be long enough for the attacker to correlate all the network activity he is meaning 
to correlate. However, they do introduce a limit to the attack window, and the amount of time during which address-based network activity correlation can be performed.
</t>
<!--
Temporary addresses (as opposed to stable addresses) may limit the exposure of an 
address to attack, and may help to mitigate network activity correlation. We note 
that the extent to which temporary addresses provide improved mitigation of network 
activity correlation and/or reduced attack exposure may be questionable in a number 
of scenarios. For example, a temporary address that is reachable for, say, a few 
hours has a questionable "reduced exposure" (particularly when automated attack 
tools do not typically require such a long period of time to complete their task). 
Similarly, if network activity can be correlated for the life of such address 
(e.g., in the order of several hours), there are scenarios in which such period of 
time would be long enough for an attacker to correlate all the network activity he 
is meaning to correlate.-->


<t>
In order to better mitigate network activity correlation and/or possibly reduce host 
exposure, an implementation might want to either reduce the preferred lifetime of a 
temporary address, or even better, generate one new temporary address for each new 
transport protocol instance. However, the associated lifetime/stability of an address 
may have a negative impact on the network (please see <xref target="operational-considerations"/>.
</t>

<t>Additionally, enforcing a maximum lifetime on IPv6 addresses may cause long-lived 
TCP connections to fail. For example, an address becoming "Invalid" (after transitioning 
through the "Preferred" and "Deprecated" states) would cause the TCP connections 
employing them to break. This, in turn, would cause e.g. long-lived SSH sessions to break/fail.
</t>

<t>
In some scenarios, attack exposure may be reduced by limiting the usage of temporary 
addresses to outgoing connections, and prevent such addresses from being used for 
incoming connections (please see <xref target="usage-type-considerations"/>).
</t>

      <t>The desires of protecting individual privacy versus the
      desire to effectively maintain and debug a network can
      conflict with each other. Having clients e.g. use addresses that
      change over time will make it more difficult to track down
      and isolate operational problems. For example, when looking
      at packet traces, it could become more difficult to determine
      whether one is seeing behavior caused by a single errant
      machine, or by a number of them.</t>

</section>


<section title="Usage Type Considerations" anchor="usage-type-considerations">
<t>IPv6 hosts may typically automatically-configure (whether via SLAAC or via DHCPv6) both stable <xref target="RFC8064"/> and/or temporary <xref target="RFC4941"/> addresses. When both stable and temporary addresses are configured, stable addresses are typically employed for incoming (server-like) communications, while temporary addresses are employed for outgoing (client-like) communications. That is, the stability properties of an address have an implicitly associated usage type.
</t>

<t>
A node that employs one of its addresses to communicate with an external server 
(i.e., to perform an "outgoing connection") may cause such address to become exposed 
to attack. For example, once the external server receives an incoming connection, 
the corresponding server might launch an attack against the aforementioned address. 
A real-world instance of this type of scenario has been documented in <xref target="Hein"/>.
</t>

<t>
However, we note that employing an IPv6 address for outgoing communications need 
not increase the exposure of local services to other parties. For example, nodes 
could employ temporary addresses only for outgoing communications, and disallow their use for incoming 
communications. Thus, external nodes that learn about client's addresses could not really 
leverage such addresses for actively contacting clients.
</t>

<t>
<xref target="ipv6-address-usage"/> discusses current IPv6 address usage, along with possible improvements.</t>
<!--
<t>There are multiple ways in which this could possibly be achieved, with different 
implications. Namely:
<list style="symbols">
<t>Run a host-based or network-based firewall</t>
<t>Bind services to specific (explicit) addresses</t>
<t>Bind services only to stable addresses</t>
</list>
</t>
-->
<!--
<t>
A client could simply run a host-based firewall that only allows incoming connections 
on the stable addresses. This is clearly more of an operational way of achieving the 
desired functionality, and may require good firewall/host integration (e.g., the firewall 
should be able to tell stable vs. temporary addresses), may require the client to run 
additional firewall software for this specific purpose, etc. In other scenarios, a 
network-based firewall could be configured to allow outgoing communications from all 
internal addresses, but only allow incoming communications to stable addresses (i.e., white-list such addresses either manually, or via a helper protocol such as <xref target="UPnP"/>). For 
obvious reasons, this is generally only applicable to networks where incoming communications 
are allowed to a limited number of hosts/servers.
</t>
-->
<!--
<t>Services could be bound to specific (explicit) addresses, rather than to all 
locally-configured addresses. However, there are a number of short-comings associated 
with this approach. Firstly, an application would need to be able to learn all of its 
addresses and associated properties, something that tends to be non-trivial 
and non-portable, and that also makes applications protocol-dependent, unnecessarily. 
Secondly, the BSD Sockets API does not allow a socket to be bound to a subset of 
the node's addresses. That is, sockets can be bound to a single address or to all 
available addresses (wildcard), but not to a subset of all the configured addresses.
</t>
-->

<!--
<t>Binding services only to stable addresses provides a clean separation between addresses 
employed for client-like outgoing comminications and server-like incoming communications. 
However, we currently lack an appropriate API for nodes to be able to specify that a 
socket should only be bound to stable addresses. 

</t>
-->
</section>


</section> <!-- address considerations -->


<section title="IPv6 Address Usage" anchor="ipv6-address-usage">
<section title="Default Address Selection" anchor="default-address-selection">
<t>
Applications use system API's to select the IPv6 addresses that will be used
for incoming and outgoing connections. These choices have consequences in terms
of privacy, security, stability and performance.
</t>
<t>
Default Address Selection for IPv6 is specified in <xref target="RFC6724" />. The
selection starts with a set of potential destination addresses, such as 
returned by getaddrinfo(), and the set of potential source addresses currently
configured for the selected interfaces. For each potential destination address,
the algorithm will select the source address that provides the best route to the 
destination, while choosing the appropriate scope and preferring temporary addresses.
The algorithm will then select the destination address, while giving a preference to
reachable addresses with the smallest scope. The selection may be affected by system
settings. We note that <xref target="RFC6724" /> only applies for outgoing connections, such
as those made by clients trying to use services offered by other hosts.</t>

<t>We note that <xref target="RFC6724"/> selects IPv6 addresses from all the currently available addresses on the host, and there is currently no way for an application to indicate expected or desirable properties for the IPv6 source addresses employed for such outgoing communications. For example, a privacy-sensitive application might want that each outgoing communication instance employs a new, single-use IPv6 address, or to employ a new reusable address that is not employed or reusable by any other application on the host. Reuse of an IPv6 address by an application would allow the correlation of all network activities corresponding to such application as being performed by the same host, while reuse of an IPv6 address by multiple different applications would allow the correlation of all such network activities as being performed by the host with such IPv6 address.</t>


<t>
When devices provide a service, the
common pattern is to just wait for connections over all addresses configured on the 
device. For example, applications using the BSD Sockets API will commonly bind() the listening 
socket to the undefined address. This long-established behavior is appropriate
for devices providing public services, but may have unexpected results for devices
providing semi-private services, such as various forms of peer-to-peer or local-only
applications.
</t> 
<t>
This behavior leads to three problems: device tracking, discussed in 
<xref target="deviceTracking"/>; unexpected address discovery, discussed in
<xref target="unexpectedDisco"/>; and availability outside the expected scope,
discussed in <xref target="availableOutside"/>. These problems are caused in part
by the limitations of available address selection API, presented in <xref target="limitedApi"/>.
</t>

</section> <!-- default address selection -->




<section title="Problem Statement" anchor="problem-statement">
<!--
<t>This section elaborates the problem statement on IPv6 address usage. <xref target="issues"/> describes the security and privacy implications of improper IPv6 address usage, while <xref target="limitedApi"/>, <xref target="advice-usage"/>, <xref target="advice-configuration"/>, analyze the possible root of such improper address usage, suggesting possible future work.</t>
-->
<section title="Issues Associated with Sub-optimal IPv6 Address Usage" anchor="issues">

<section title="Correlation of Network Activity"  anchor="correlation">

<t>
As discussed in <xref target="RFC7721"/>, a node that reuses an IPv6 address for multiple communication instances would allow the correlation of such network activities. This could be the case when the same IPv6 address is employed by several instances of the same application (e.g., a browser in "privacy" mode and a browser in "normal" mode), or when the same IPv6 address is employed by two different applications on the same node (e.g., a browser in "privacy" mode, and an email client).</t> 

<t>Particularly for privacy-sensitive applications, an application or system might want to limit the usage of a given IPv6 address to a single communication instance, a single application, a single user on the system, etc. However, given current APIs, this is practically impossible.</t>
</section>


<section title="Testing for the Presence of Node in the Network"  anchor="deviceTracking">
<!-- [fgont] 'Device tracking' is not the right term here... but still havent been able to come up with something better -->

<t>
The stable addresses recommended in <xref target="RFC8064" /> use stable IIDs defined
in <xref target="RFC7217" />. One key part of that algorithm is that if a device
connects to a given network at different times, it will always configure the
same IPv6 addresses on that network. If the device hosts a service ready to 
accept connections on that stable address, adversaries can test the presence of the 
device on the network by attempting connections to that stable address. Stable addresses
used by listening services will thus enable testing whether a specific device is
returning to a particular network, which
in a number of cases might be considered a privacy issue.


</t> 
</section>


<section title="Unexpected Address Discovery" anchor="unexpectedDisco" >
<t>
Systems like DNS-Based Service Discovery <xref target="RFC6763" /> allow clients to 
discover services within a limited scope, that can be defined by a domain name. These
services are not advertised outside of that scope, and thus do not expect to be 
discovered by random parties on the Internet. However, such services
may be easily discoverable if they listen for connections to IPv6 addresses that 
a client process also uses as source address when connecting to remote servers.
<list style="hanging">
<t hangText="NOTE:"><vspace blankLines="0"/>
An example of such unexpected discovery is described in <xref target="Hein" />. A network 
manager observed scanning traffic directed at the temporary addresses of local devices.
The analysis in  <xref target="Hein" /> shows that the scanners learned the addresses by observing the device 
contact an NTP service (<xref target="RFC5905" />). The remote scanning was possible
because the local devices were also accepting connections directed to the temporary
addresses.
</t>
</list>
</t>
<t>
It is obvious from the example that the "attack surface" of the services is increased 
because they are bond to the same IPv6 addresses that are also used by clients for outgoing communications with remote systems. But the overlap between "client" and "server" addresses is only one part of
the problem. Suppose that a device hosts both a video game and a home automation 
application. The video game users will be able to discover the IPv6 address of the
game server. If the home automation server listens to the same IPv6 addresses, it 
is now exposed to connection attempts by all these users. That, too, increases the
attack surface of the home automation server.
</t>
</section>

<section title="Availability Outside the Expected Scope"  anchor="availableOutside">
<t>
The IPv6 addressing architecture <xref target='RFC4291' /> defines multiple address 
scopes. In practice, devices are often configured with globally reachable 
unicast addresses,
link local addresses, and Unique Local IPv6 Unicast Addresses (ULA) 
<xref target="RFC4193" />. Availability outside the expected scope happens when 
a service is expected to be only available in some local scope, but inadvertently becomes
available to remote parties. That could happen for example if a service is meant
to be available only on a given link, but becomes reachable through ULA or through
globally reachable addresses, or if a service is meant to be available only inside
some organization's perimeter and becomes reachable through
globally reachable addresses. It will happen in particular if a service intended for
some local scope is programmed to bind to "unspecified" addresses, which in 
practice means every address configured for the device (please see <xref target="limitedApi"/>).
</t>
</section>
</section> <!-- issues with... -->

<section title="Issues Associated with Sub-optimal Address Configuration" anchor="operational-considerations">

<t>While IPv6 SLAAC provides hosts with great flexibility when it comes to address auto-configuration, it may also result in network configuration anarchy, where hosts may configure and use addresses in a way that may render the network virtually unusable.</t>

<!-- XXXX To be improved -->
<t>Network deployments are currently recommended to provide multiple IPv6 addresses from each prefix to general-purpose hosts <xref target="RFC7934"/>. However, in some scenarios, use of a large number of IPv6 addresses may have negative implications on network devices that need to maintain entries for each IPv6 address in some data structures (e.g., <xref target="RFC7039"/>). Additionally, concurrent active use of multiple IPv6 addresses will increase neighbour discovery traffic if Neighbour Caches in network devices are not large enough to store all addresses on the link. This can impact performance and energy efficiency on networks on which multicast is expensive (e.g. <xref target="I-D.ietf-mboned-ieee802-mcast-problems"/>). Finally, network devices may interpret the use of a number of addresses above a certain threshold as a security event, and block the offending device from using the network.</t>
</section>
</section>

<section title="Current Alternatives for IPv6 Address Usage" anchor="approaches">


<section title="Incoming communications" anchor="approach-incoming">
<t>There are a number of ways in which a system or network may affect which address (and how) may be employed for different services and cases. Namely,

<list style="symbols">
<t>TCP/IP stack address filtering</t>
<t>Application-based address filtering</t>
<t>Firewall-based address filtering</t>
</list>
</t>

<t>Clearly, the most elegant approach for address selection would be for applications to be able to specify the properties of the addresses they are 
willing to employ by means of an API, such the TCP/IP stack itself could "filter" which addresses are allowed to be employed for the given service/application. For example, an application could specify the stability and scope properties of the addresses on which incoming communications should be accepted. This would relieve the application from dealing with low level details of networking, improve portability, and avoid duplicate code in applications. However, constraints in the current APIs (see <xref target="limitedApi"/>) limit the ability of application programmers for leveraging this technique. Similarly, services could be bound to specific (explicit) addresses, rather than to all 
locally-configured addresses. However, there are a number of short-comings associated 
with this approach. Firstly, an application would need to be able to learn all of its 
addresses and associated properties, something that tends to be non-trivial 
and non-portable, and that also makes applications protocol-dependent, unnecessarily. 
Secondly, the BSD Sockets API does not allow a socket to be bound to a subset of 
the node's addresses. That is, sockets can be bound to a single address or to all 
available addresses (wildcard), but not to a subset of all the configured addresses.
</t>

<t>Another possible approach would be for applications to e.g. bind services to all available addresses, and perform the associated selection/filtering at the application level. While possible, this would have a number of drawbacks. Firstly, it would require applications to deal with low-level networking details, require that all the associated code be duplicated in all applications, and also negatively affect portability. Besides, performing address/selection filtering at the application level may not mitigate some possible threats. For example, port scanning will still be possible, since the aforementioned filtering will only be performed e.g. once UDP packets are received or TCP connections are established.
</t>

<t>
A client could simply run a host-based firewall that only allows incoming connections 
on the stable addresses. This is clearly more of an operational way of achieving the 
desired functionality, and may require good firewall/host integration (e.g., the firewall 
should be able to tell stable vs. temporary addresses), may require the client to run 
additional firewall software for this specific purpose, etc. In other scenarios, a 
network-based firewall could be configured to allow outgoing communications from all 
internal addresses, but only allow incoming communications to stable addresses (i.e., white-list such addresses either manually, or via a helper protocol such as <xref target="UPnP"/>). For 
obvious reasons, this is generally only applicable to networks where incoming communications 
are allowed to a limited number of hosts/servers.
</t>
<!--
<t>Finally, a firewall could be employed to filter addresses based on their intended usage. For example, a firewall could block incoming requests to all addresses except to some whitelisted addresses (such as the stable addresses of the node). This technique would not only require the use of a firewall (which may or may not be present), but would also imply knowledge of the firewall regarding the desired properties of the addresses that each application/service is intended to use.
</t>-->
</section>

<section title="Outgoing communications" anchor="approach-outgoing">
<t>An application might be able to obtain the list of currently-configured addresses, and subsequently select an address with desired properties,  and explicitly "bind" the address to the socket, to override the default source address selection.</t>
<t>However, this approach is problematic for a number of reasons. Firstly, there is no portable way of obtaining the list of currently-configured addresses on the local node, and even less to check for properties such "valid lifetime". Secondly, as discussed in <xref target="approach-incoming"/>, it would require application programmers to understand all the subtleties associated with IPv6 addressing, and would also lead to duplicate code on all applications. Finally, applications would be limited to use already-configured addresses and unable to trigger the generation of new addresses where desirable (e.g. the generation of a new temporary address for this application instance or communication instance).</t>
</section>

</section> <!-- approaches -->

</section>


<section title="Current Gaps that Prevent Leveraging IPv6 Addressing">
<section title="Better Address Selection APIs" anchor="limitedApi" >
<t>
Application developers using the BSD Sockets API can "bind" a listening socket to a specific
address, and ensure that the application is only reachable through that address. In
theory, careful selection of the binding address could mitigate the problems described in <xref target="issues"/>. Binding services to temporary addresses could mitigate the ability of an attacker from testing for the presence of the node in the network.
Binding different services to different addresses could mitigate unexpected discovery.
Binding services to link local addresses or ULA could mitigate availability outside the
expected scope. However,
explicitly managing addresses adds significant complexity to the application development.
It requires that application developers master addressing architecture subtleties, and 
implement logic that reacts adequately to connectivity events and address changes. 
Experience shows that application developers would probably prefer some much simpler solution.
</t>
<t>
In addition, we should note that many application developers use high level APIs that
listen to TLS, HTTP, or some other application protocol. These high level APIs seldom
provide detailed access to specific IP addresses, and typically default to listening
to all available addresses.
</t>

<t>A more advanced API could allow an application programmer to select desired properties in an address (scope, lifespan, etc.), such that the best-suitable addresses are selected, while relieving the application for low-level IPv6 addressing details. Such API might also trigger the generation of new IPv6 addresses when the specified properties would require so.</t>

</section> <!-- limited api -->

<section title="Advice on IPv6 Address Usage" anchor="advice-usage">
<t>An application programmer, left with the question of which are the most appropriate addresses for a given usage type and application, typically resorts to the Default IPv6 Address Selection for IPv6 (see <xref target="default-address-selection"/>) for outgoing communications, and to accepting incoming communications on all available addresses for incoming communications. As discussed throughout this document, this leads to sub-optimal results. Besides, all applications on a node share the same pool of configured addresses, and applications are also prevented from triggering the generation of new addresses (e.g. to be employed for a particular application or communication instance).</t>

<t>Guidance in this area is warranted such that applications and systems fully-leverage IPv6 addressing.</t>


<t>
<list style="hanging">
<t hangText="NOTE:"><vspace blankLines="0"/>
Such guidance would elaborate, among other things, on the usage of IPv6 addresses when offering network services and when performing client-like communications. For example, for incoming communications, hosts might want to employ only the smallest-scope applicable addresses (if available) and, if stable addresses are available, they might want to accept incoming connections only on such addresses (but *not* on temporary addresses). For client-like communications, hosts might prefer temporary addresses, unless the corresponding communication instances are expected to be long-lived (e.g., SSH sessions).</t>
</list>
</t>
</section>

<section title="Network-Specific IPv6 Address Configuration" anchor="advice-configuration">
<t>Most operating systems configure the same types of addresses regardless of the current "operating mode" or "profile" of the device (e.g., device connected to enterprise network vs roaming across untrusted networks). For example, many operating systems configure both stable <xref target="RFC8064"/> and temporary <xref target="RFC4941"/> addresses on all network interfaces. However, this "one size fits all" approach tends to be sub-optimal or inappropriate for some scenarios. For example, enterprise networks typically prefer usage of only stable address, thus meaning that a network administrator needs to find the means for disabling the generation of temporary addresses on all those systems that would otherwise generate them. On the other hand, some mobile devices configure both stable and temporary addresses, even when their usage pattern (client-like operation, as opposed to offering services to other nodes) would allow for the more privacy-sensible option of configuring only temporary addresses.
</t>

<t>The lack of better tuned address configuration policies has helped the "one size fits all" approach that, as noted, may lead to suboptimal results. Advice in this area might help achieve more optional address generation policies such that IPv6 addressing capabilities are fully leveraged.</t>

<t>
<list style="hanging">
<t hangText="NOTE:"><vspace blankLines="0"/>
One might envision a document that provides advice regarding the address generation for different typical scenarios (e.g., when to configure stable-only, temporary-only, or stable+temporary). In the most simple analysis, one might expect nodes in a typical enterprise network to employ only stable addresses. General-purpose nodes in a home or "trusted" network may want to employ both stable and temporary addresses. Finally, mobile nodes (e.g. when roaming across non-trusted networks) may want to employ only temporary addresses).
</t>
</list>
</t>
</section>

<section title="SLAAC Protocol Improvements" anchor="slaac-improvements">
<t>It would be desirable to evaluate the possible need for improvements in IPv6 SLAAC, including:

<list style="symbols">
<t>Enabling IPv6 routers to convey information about the maximum number of addressees</t>
<t>Enabling hosts to register/de-register configured addresses, such that e.g. routers need not tie resources to addresses that are no longer used</t>
</list>
</t>

</section>


<section title="Support of Firewall Traversal in CE Routers" anchor="ce-routers">
<t>Customer Edge Routers that implement a default filtering policy of "only allowing outgoing communications" need to support helper protocols such as <xref target="UPnP"/> such that applications can punch holes in the CE Router firewall for applications that need to receive incoming communications. Otherwise, P2P applications that currently work in IPv4 could not function properly in IPv6-only networks.</t>
</section>


<section title="Universal Support of Multi-prefix/Multi-router Networks" anchor="multi-networks">
<t>To put it bluntly, multi-prefix/multi-router networks cannot possibly work properly without implementation of <xref target="RFC8028"/>. Unfortunately, <xref target="RFC8028"/> is not widely implemented. On the protocol standardization side, the IETF should consider elevating the requirement to support RFC8028 in the IPv6 Node Requirements RFC <xref target="RFC8504"/> from "SHOULD" to "MUST".
</t>
</section>
</section>

	<section title="IANA Considerations" anchor="iana-considerations">
<t>There are no IANA registries within this document. The RFC-Editor can remove this section before publication of this document as an RFC.</t>
</section>

    <section title="Security Considerations">
<t>The security and privacy implications associated with the predictability and lifetime of IPv6 addresses has been analyzed in <xref target="RFC7217"/> <xref target="RFC7721"/>, and <xref target="RFC7707"/>. This document complements and extends the aforementioned analysis by considering other IPv6 properties such as the address scope and address usage type, and the associated tradeoffs. Finally, it describes possible future standards-track work to allow for greater flexibility in IPv6 address usage.</t>

    </section>

    <section title="Acknowledgements">
<t>The authors would like to thank (in alphabetical order) Francis Dupont, Tatuya Jinmei, and Dave Thaler for providing valuable comments on earlier versions of this document.</t>

<!--
<t><xref target="operational-considerations"/> borrows text from <xref target="I-D.ietf-6man-rfc4941bis"/> co-authored by Fernando Gont, Suresh Krishnan, Thomas Narten, and Richard Draves.
</t>
-->
</section>


  </middle>

  <back>
  <references title='Normative References'>
<!--
	<?rfc include="reference.RFC.2460" ?>
-->
	<?rfc include="reference.RFC.2119" ?>
	<?rfc include="reference.RFC.4007" ?>
	<?rfc include="reference.RFC.4193" ?>
	<?rfc include="reference.RFC.4291" ?>
	<?rfc include="reference.RFC.4941" ?>
	<?rfc include="reference.RFC.5905" ?>
	<?rfc include="reference.RFC.6724" ?>
	<?rfc include="reference.RFC.6763" ?>
	<?rfc include="reference.RFC.7217" ?>
	<?rfc include="reference.RFC.8028" ?>
	<?rfc include="reference.RFC.8064" ?>
	<?rfc include="reference.RFC.7934" ?>
	<?rfc include="reference.RFC.8415" ?>
	<?rfc include="reference.RFC.8504" ?>
  </references>

  <references title='Informative References'>

<!-- Problems with multiple addresses -->
	<?rfc include="reference.I-D.ietf-mboned-ieee802-mcast-problems" ?>
	<?rfc include="reference.I-D.ietf-6man-rfc4941bis" ?>
	<?rfc include="reference.RFC.6296" ?>
	<?rfc include="reference.RFC.7039" ?>

	<?rfc include="reference.RFC.7707" ?>
	<?rfc include="reference.RFC.7721" ?>

	<?rfc include="reference.RFC.8190" ?>

	<?rfc include="reference.I-D.ietf-v6ops-ula-usage-considerations" ?>

	<?rfc include="reference.I-D.gont-opsawg-firewalls-analysis" ?>




      <reference anchor="Barnes2012" target="https://www.caida.org/workshops/isma/1202/slides/aims1202_rbarnes.pdf">
        <front>
          <title>Mapping the Great Void Smarter scanning for IPv6</title>

          <author fullname="Richard Barnes" initials="R." surname="Barnes">
          </author>


          <author fullname="Rick Altmann" initials="R." surname="Altmann">
          </author>



          <author fullname="Daniel Kerr" initials="D." surname="Kerr">
          </author>


          <date/>
        </front>

        <seriesInfo name=""
                    value="ISMA 2012 AIMS-4 - Workshop on Active Internet Measurements, February 2012"/>
      </reference>



      <reference anchor="UPnP" target="https://openconnectivity.org/upnp-specs/UPnP-arch-DeviceArchitecture-v2.0-20200417.pdf">
        <front>
          <title>UPnP Device Architecture 2.0</title>

          <author fullname="UPnP" initials="" surname="UPnP">
          </author>

          <date/>
        </front>

        <seriesInfo name=""
                    value="April 17, 2020"/>
      </reference>

      <reference anchor="Hein" target="http://netpatterns.blogspot.be/2016/01/the-rising-sophistication-of-network.html">
        <front>
          <title>The Rising Sophistication of Network Scanning</title>

          <author fullname="Brad Hein" initials="B." surname="Hein">
          </author>

          <date/>
        </front>

        <seriesInfo name=""
                    value="January 2016"/>
      </reference>

</references>

  </back>

</rfc>
